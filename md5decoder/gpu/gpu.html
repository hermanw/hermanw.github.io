<!doctype html>

<html>

<head>
  <meta charset="utf-8">
  <style>
    body {
      font-family: Verdana, sans-serif;
    }
  </style>
  <title>MD5/SHA256 Decoder</title>
  <script src="glsl_src.js"></script>
</head>

<body>
  <h2>MD5/SHA256 Decoder - for China Mobile Number</h2>
  <div>
    <label>Algorithm:
      <select id="algorithm">
        <option value="MD5">MD5</option>
        <option value="SHA256">SHA256</option>
      </select>
    </label>
  </div>
  <br>
  <div>paste hashes here:(comma separated)</div>
  <textarea id='input' cols="80" rows="8"></textarea>
  <br><button onclick="decode()">decode</button><span id='adapter'></span>
  <br><label id='info' hidden='true'></label>
  <br><progress id="bar_search" hidden='true' value="0" max="1"></progress>&nbsp;<label id='label_search'
    hidden='true'></label>
  <br><progress id="bar_complete" hidden='true' value="0" max="1"></progress>&nbsp;<label id='label_complete'
    hidden='true'></label>
  <br><textarea id='output' hidden='true' readonly='true' cols="80" rows="8"></textarea>
  <script>
    var adapter;
    var device;
    testGpu();

    async function testGpu() {
      if (!navigator.gpu) {
        document.getElementById('adapter').innerHTML = "...WebGPU not supported by your browser.";
      } else {
        adapter = await navigator.gpu.requestAdapter({
          powerPreference: 'high-performance'
        });
        device = await adapter.requestDevice();
        document.getElementById('adapter').innerHTML = " using GPU.";
      }
    }

    function yieldToBrowser() {
      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          resolve();
        }, 0);
      });
    }

    async function updateProgress(prefix_len, prefix_progress, len, count, startTime) {
      const bar_search = document.getElementById('bar_search');
      const label_search = document.getElementById('label_search');
      const bar_complete = document.getElementById('bar_complete');
      const label_complete = document.getElementById('label_complete');
      bar_search.hidden = false;
      label_search.hidden = false;
      bar_complete.hidden = false;
      label_complete.hidden = false;
      bar_search.max = prefix_len;
      bar_search.value = prefix_progress;
      bar_complete.max = len;
      bar_complete.value = count;
      const cost = Math.round((new Date() - startTime) / 1000);
      label_search.innerText = "searching complete " + Math.round(prefix_progress * 100 / prefix_len) + "%" + " in " + cost + " seconds";
      label_complete.innerText = count + "/" + len + " are decoded";
      await yieldToBrowser();
    }

    function progressHashString(input, hashLength) {
      var hashes = [];
      input.split(',').forEach(element => {
        var e = element.trim();
        if (e.length == hashLength) {
          hashes.push(e);
        }
      });
      return hashes;
    }

    function compareHash(shArray, a, b, hashWords) {
      var sh32 = new Uint32Array(shArray.buffer);
      for (var i = 0; i < hashWords; i++) {
        var va = sh32[a * hashWords + i];
        var vb = sh32[b * hashWords + i];
        if (va < vb) {
          return -1;
        }
        else if (va > vb) {
          return 1;
        }
      }

      return 0;
    }

    function exchangeHash(shArray, a, b, hashBytes) {
      for (var i = 0; i < hashBytes; i++) {
        var temp = shArray[a * hashBytes + i];
        shArray[a * hashBytes + i] = shArray[b * hashBytes + i];
        shArray[b * hashBytes + i] = temp;
      }
    }

    function quickSort(shArray, indexArray, from, to, hashWords, hashBytes) {
      if (from >= to) return;
      var i = from;
      for (var j = from + 1; j <= to; j++) {
        if (compareHash(shArray, j, from, hashWords) < 0) {
          i = i + 1;
          exchangeHash(shArray, i, j, hashBytes);
          var temp = indexArray[i];
          indexArray[i] = indexArray[j];
          indexArray[j] = temp;
        }
      }
      exchangeHash(shArray, i, from, hashBytes);
      var temp = indexArray[i];
      indexArray[i] = indexArray[from];
      indexArray[from] = temp;

      quickSort(shArray, indexArray, from, i - 1, hashWords, hashBytes);
      quickSort(shArray, indexArray, i + 1, to, hashWords, hashBytes);
    }

    function dedupSortedHash(shArray, indexArray, indexDedupArray, hashWords, hashBytes) {
      var dedup_len = indexArray.length;
      for (var i = 1; i < dedup_len; i++) {
        if (compareHash(shArray, i, i - 1, hashWords) == 0) {
          var temp_index = indexArray[i];
          var temp_index_dup = indexArray[i - 1];
          for (var j = i; j < indexArray.length - 1; j++) {
            exchangeHash(shArray, j, j + 1, hashBytes);
            indexArray[j] = indexArray[j + 1];
            indexDedupArray[j] = indexDedupArray[j + 1];
          }
          indexArray[indexArray.length - 1] = temp_index
          indexDedupArray[indexArray.length - 1] = temp_index_dup;
          dedup_len--;
          i--;
        }
      }
      return dedup_len;
    }

    function sortHash(hashes, hashBytes) {
      var len = hashes.length;
      var shArray = new Uint8Array(hashBytes * len);
      var indexArray = new Uint32Array(len);
      var indexDedupArray = new Uint32Array(len);
      var hashWords = hashBytes / 4;

      for (let j = 0; j < len; j++) {
        indexArray[j] = j;
        for (let i = 0; i < hashBytes; i++) {
          shArray[j * hashBytes + i] = parseInt(hashes[j].substr(i * 2, 2), 16);
        }

        // Handle Big Endian for SHA256 (32 bytes)
        // We swap bytes in each 4-byte word so that Little Endian load matches Big Endian value
        if (hashBytes === 32) {
          for (let k = 0; k < 32; k += 4) {
            let idx = j * 32 + k;
            let b0 = shArray[idx];
            let b1 = shArray[idx + 1];
            let b2 = shArray[idx + 2];
            let b3 = shArray[idx + 3];
            shArray[idx] = b3;
            shArray[idx + 1] = b2;
            shArray[idx + 2] = b1;
            shArray[idx + 3] = b0;
          }
        }
      }

      // quick sort
      quickSort(shArray, indexArray, 0, len - 1, hashWords, hashBytes);
      var dedup_len = dedupSortedHash(shArray, indexArray, indexDedupArray, hashWords, hashBytes);
      return [shArray, indexArray, indexDedupArray, dedup_len];
    }

    async function decode() {
      if (!navigator.gpu) {
        return;
      }

      // Get all UI elements
      const info = document.getElementById('info');
      const output = document.getElementById('output');
      const bar_search = document.getElementById('bar_search');
      const label_search = document.getElementById('label_search');
      const bar_complete = document.getElementById('bar_complete');
      const label_complete = document.getElementById('label_complete');
      const algorithm = document.getElementById('algorithm').value;

      const hashLength = algorithm === 'MD5' ? 32 : 64;
      const hashBytes = algorithm === 'MD5' ? 16 : 32;

      // process inputs
      const hashes = progressHashString(document.getElementById("input").value, hashLength);

      if (hashes.length === 0) {
        info.hidden = false;
        info.innerText = "Please enter at least one valid " + hashLength + "-character " + algorithm + " hash.";
        output.hidden = true;
        bar_search.hidden = true;
        label_search.hidden = true;
        bar_complete.hidden = true;
        label_complete.hidden = true;
        return;
      }

      const [shArray, indexArray, indexDedupArray, dedup_len] = sortHash(hashes, hashBytes);

      info.hidden = false;
      info.innerText = "find " + dedup_len + " valid unique hashes";
      output.hidden = true;

      // Allocate GPU buffer
      // 0. SortedHash
      const bufHash = device.createBuffer({
        size: hashBytes * dedup_len,
        usage: GPUBufferUsage.STORAGE,
        mappedAtCreation: true,
      });
      new Uint8Array(bufHash.getMappedRange()).set(shArray.slice(0, hashBytes * dedup_len));
      bufHash.unmap();
      // 1. mobile data (we output 3 words = 12 bytes per result, padded to 16 bytes vec3<u32>? No, array<vec3<u32>> implies alignment. vec3 is usually padded to 16 bytes in arrays)
      // Wait, in previous code: size: 16 * dedup_len. vec3<u32> is 12 bytes but typical array alignment (std140) in storage buffers might be 16 bytes.
      // WGSL Default memory layout (storage class) for array<vec3<u32>> usually has 16-byte stride.
      // previous implementation used 16 * dedup_len. I will stick to that.

      const bufData = device.createBuffer({
        size: 16 * dedup_len,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
      });
      const bufDataRead = device.createBuffer({
        size: 16 * dedup_len,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      });
      // 2. numbers
      const numbersSize = 10000;
      const numbersArray = new Uint8Array(numbersSize * 4);
      for (let i = 0; i < numbersSize; i++) {
        numbersArray[i * 4] = Math.floor(i / 1000) + 48;
        numbersArray[i * 4 + 1] = Math.floor(i / 100) % 10 + 48;
        numbersArray[i * 4 + 2] = Math.floor(i / 10) % 10 + 48;
        numbersArray[i * 4 + 3] = i % 10 + 48;
      }
      const bufNumbers = device.createBuffer({
        size: numbersSize * 4,
        usage: GPUBufferUsage.STORAGE,
        mappedAtCreation: true,
      });
      new Uint8Array(bufNumbers.getMappedRange()).set(numbersArray);
      bufNumbers.unmap();
      // 3. params
      const bufParams = device.createBuffer({
        size: 20,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
      });
      const bufParamsWrite = device.createBuffer({
        size: 20,
        usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC
      });
      const bufParamsRead = device.createBuffer({
        size: 20,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
      });

      // Bind data group
      const bindGroupLayout = device.createBindGroupLayout({
        entries: [
          {
            binding: 0,
            visibility: GPUShaderStage.COMPUTE,
            buffer: {
              type: "read-only-storage"
            }
          },
          {
            binding: 1,
            visibility: GPUShaderStage.COMPUTE,
            buffer: {
              type: "storage"
            }
          },
          {
            binding: 2,
            visibility: GPUShaderStage.COMPUTE,
            buffer: {
              type: "read-only-storage"
            }
          },
          {
            binding: 3,
            visibility: GPUShaderStage.COMPUTE,
            buffer: {
              type: "storage"
            }
          }
        ]
      });
      const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
          { binding: 0, resource: { buffer: bufHash } },
          { binding: 1, resource: { buffer: bufData } },
          { binding: 2, resource: { buffer: bufNumbers } },
          { binding: 3, resource: { buffer: bufParams } }
        ]
      });

      // Compute shader code
      const shaderModule = device.createShaderModule({
        code: getWgslSource(algorithm)
      });

      const computePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
          bindGroupLayouts: [bindGroupLayout]
        }),
        compute: {
          module: shaderModule,
          entryPoint: "main"
        }
      });

      const PREFIX_LIST = [
        '186', '158', '135', '159',
        '136', '150', '137', '138',
        '187', '151', '182', '152',
        '139', '183', '188', '134',
        '185', '189', '180', '157',
        '155', '156', '131', '132',
        '133', '130', '181', '176',
        '177', '153', '184', '178',
        '173', '147', '175', '199',
        '166', '170', '198', '171',
        '191', '145', '165', '172',
        '154', '146'
      ];
      // const PREFIX_LIST = [
      //   '186', '158'
      // ];  
      const startTime = new Date();
      let count = 0;
      await updateProgress(PREFIX_LIST.length, 0, dedup_len, count, startTime);
      for (let i = 0; i < PREFIX_LIST.length; i++) {
        if (count == dedup_len) {
          break;
        }
        const prefix = PREFIX_LIST[i];

        // Encode the compute commands.
        const commandEncoder = device.createCommandEncoder();
        // write params
        await bufParamsWrite.mapAsync(GPUMapMode.WRITE);
        const paramsArray = new Uint32Array(bufParamsWrite.getMappedRange());
        paramsArray[0] = dedup_len;
        paramsArray[1] = count;
        paramsArray[2] = prefix.charCodeAt(0);
        paramsArray[3] = prefix.charCodeAt(1);
        paramsArray[4] = prefix.charCodeAt(2);
        bufParamsWrite.unmap();
        commandEncoder.copyBufferToBuffer(
          bufParamsWrite,
          0,
          bufParams,
          0,
          20
        );

        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(computePipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.dispatchWorkgroups(
          625, // 10000 / 16
          625  // 10000 / 16
        );
        passEncoder.end();

        // read params
        commandEncoder.copyBufferToBuffer(
          bufParams,
          0,
          bufParamsRead,
          0,
          20
        );

        // Submit work to the GPU.
        const gpuCommands = commandEncoder.finish();
        device.queue.submit([gpuCommands]);

        // read result
        await bufParamsRead.mapAsync(GPUMapMode.READ);
        count = new Uint32Array(bufParamsRead.getMappedRange())[1];
        bufParamsRead.unmap();

        await updateProgress(PREFIX_LIST.length, i + 1, dedup_len, count, startTime);
      };

      // read data
      const commandEncoder = device.createCommandEncoder();
      commandEncoder.copyBufferToBuffer(
        bufData,
        0,
        bufDataRead,
        0,
        16 * dedup_len
      );
      const gpuCommands = commandEncoder.finish();
      device.queue.submit([gpuCommands]);

      await bufDataRead.mapAsync(GPUMapMode.READ);
      const result = new Uint8Array(new ArrayBuffer(16 * dedup_len));
      result.set(new Uint8Array(bufDataRead.getMappedRange()));
      bufDataRead.unmap();

      const resultArray = new Array(hashes.length).fill('');
      for (let i = 0; i < hashes.length; i++) {
        if (i < dedup_len) {
          let mobile = '';
          for (let j = 0; j < 11; j++) {
            mobile += String.fromCharCode(result[i * 16 + j]);
          }
          resultArray[indexArray[i]] = mobile;
        } else {
          resultArray[indexArray[i]] = resultArray[indexDedupArray[i]];
        }
      }

      // output
      output.hidden = false;
      output.value = "";
      for (let i = 0; i < hashes.length; i++) {
        output.value += hashes[i] + "," + resultArray[i] + "\n";
      }
    }
  </script>
</body>

</html>